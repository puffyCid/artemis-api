"use strict";(self.webpackChunkartemis_docs=self.webpackChunkartemis_docs||[]).push([[4592],{6937:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var s=t(5893),i=t(1151);const r={description:"How to make custom parsers"},d="Nom APIs",a={id:"API/Helper/nom",title:"Nom APIs",description:"How to make custom parsers",source:"@site/docs/API/Helper/nom.md",sourceDirName:"API/Helper",slug:"/API/Helper/nom",permalink:"/artemis-api/docs/API/Helper/nom",draft:!1,unlisted:!1,editUrl:"https://github.com/puffyCid/artemis-api/tree/main/artemis-docs/docs/API/Helper/nom.md",tags:[],version:"current",frontMatter:{description:"How to make custom parsers"},sidebar:"artemisAPI",previous:{title:"Networking APIs",permalink:"/artemis-api/docs/API/Helper/network"},next:{title:"System APIs",permalink:"/artemis-api/docs/API/Helper/system"}},o={},l=[{value:"nomUnsignedFourBytes(data, endianess) -&gt; NomUnsigned | Error",id:"nomunsignedfourbytesdata-endianess---nomunsigned--error",level:3},{value:"nomUnsignedEightBytes(data, endianess) -&gt; NomUnsigned | Error",id:"nomunsignedeightbytesdata-endianess---nomunsigned--error",level:3},{value:"nomUnsignedTwoBytes(data, endianess) -&gt; NomUnsigned | Error",id:"nomunsignedtwobytesdata-endianess---nomunsigned--error",level:3},{value:"nomUnsignedOneBytes(data, endianess) -&gt; NomUnsigned | Error",id:"nomunsignedonebytesdata-endianess---nomunsigned--error",level:3},{value:"nomUnsignedSixteenBytes(data, endianess) -&gt; NomUnsignedLarge | Error",id:"nomunsignedsixteenbytesdata-endianess---nomunsignedlarge--error",level:3},{value:"nomSignedFourBytes(data, endianess) -&gt; NomSigned | Error",id:"nomsignedfourbytesdata-endianess---nomsigned--error",level:3},{value:"nomSignedEightBytes(data, endianess) -&gt; NomSigned | Error",id:"nomsignedeightbytesdata-endianess---nomsigned--error",level:3},{value:"nomSignedTwoBytes(data, endianess) -&gt; NomSigned | Error",id:"nomsignedtwobytesdata-endianess---nomsigned--error",level:3},{value:"take(data, input) -&gt; Nom | Error",id:"takedata-input---nom--error",level:3},{value:"takeUntil(data, input) -&gt; Nom | Error",id:"takeuntildata-input---nom--error",level:3},{value:"takeWhile(data, input) -&gt; Nom | Error",id:"takewhiledata-input---nom--error",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"nom-apis",children:"Nom APIs"}),"\n",(0,s.jsxs)(n.p,{children:["Artemis uses the ",(0,s.jsx)(n.a,{href:"https://github.com/rust-bakery/nom",children:"nom"})," Rust library to parse\ndata on the system. Only some of the nom API is exposed to JavaScript runtime.\nIn addition, several nom helper functions are exposed to assist with common\nparsing tasks."]}),"\n",(0,s.jsx)(n.p,{children:"Nom is a powerful parsing framework but can be a little complex when first\nstarting. It works on both plaintext and binary data. Artemis mainly uses it for\nbinary data. But parts of the artemis-api will support plaintext as well."}),"\n",(0,s.jsx)(n.p,{children:"An highlevel overview of the way nom works:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'You give nom X bytes and tell nom to "eat" (nom) Y bytes'}),"\n",(0,s.jsxs)(n.li,{children:["Nom wil consume Y bytes then return Y bytes AND the ",(0,s.jsx)(n.strong,{children:"remaining"})," X bytes"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"So if you give nom 10 bytes and tell it eat/consume 2 bytes. You would get 2\nbytes and 8 bytes returned. Pseudo-code below"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"let input  = [0,1,2,3,4,5,6,7,8,9]; // 10 bytes\nlet take = 2;\n\nlet remaining, consumed = nom(input, take)\n\nassert!(remaining.len(), 8); // We consumed 2 bytes, we have 8 remaining\nassert!(remaining, [2,3,4,5,6,7,8,9]); // our remaining bytes!\nassert!(consumed, [0,1]); // we consumed the first 2 bytes!\n"})}),"\n",(0,s.jsx)(n.h3,{id:"nomunsignedfourbytesdata-endianess---nomunsigned--error",children:"nomUnsignedFourBytes(data, endianess) -> NomUnsigned | Error"}),"\n",(0,s.jsx)(n.p,{children:"Nom helper to parse four bytes into unsigned 32 bit integer"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Uint8Array"})}),(0,s.jsx)(n.td,{children:"Bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"endianess"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Endian"})}),(0,s.jsxs)(n.td,{children:["Endian type of ",(0,s.jsx)(n.code,{children:"data"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"nomunsignedeightbytesdata-endianess---nomunsigned--error",children:"nomUnsignedEightBytes(data, endianess) -> NomUnsigned | Error"}),"\n",(0,s.jsx)(n.p,{children:"Nom helper to parse eight bytes into unsigned 64 bit integer"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Uint8Array"})}),(0,s.jsx)(n.td,{children:"Bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"endianess"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Endian"})}),(0,s.jsxs)(n.td,{children:["Endian type of ",(0,s.jsx)(n.code,{children:"data"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"nomunsignedtwobytesdata-endianess---nomunsigned--error",children:"nomUnsignedTwoBytes(data, endianess) -> NomUnsigned | Error"}),"\n",(0,s.jsx)(n.p,{children:"Nom helper to parse two bytes into unsigned 16 bit integer"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Uint8Array"})}),(0,s.jsx)(n.td,{children:"Bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"endianess"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Endian"})}),(0,s.jsxs)(n.td,{children:["Endian type of ",(0,s.jsx)(n.code,{children:"data"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"nomunsignedonebytesdata-endianess---nomunsigned--error",children:"nomUnsignedOneBytes(data, endianess) -> NomUnsigned | Error"}),"\n",(0,s.jsx)(n.p,{children:"Nom helper to parse one bytes into unsigned 8 bit integer"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Uint8Array"})}),(0,s.jsx)(n.td,{children:"Bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"endianess"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Endian"})}),(0,s.jsxs)(n.td,{children:["Endian type of ",(0,s.jsx)(n.code,{children:"data"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"nomunsignedsixteenbytesdata-endianess---nomunsignedlarge--error",children:"nomUnsignedSixteenBytes(data, endianess) -> NomUnsignedLarge | Error"}),"\n",(0,s.jsx)(n.p,{children:"Nom helper to parse sixteen bytes into unsigned 128 bit integer as a string"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Uint8Array"})}),(0,s.jsx)(n.td,{children:"Bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"endianess"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Endian"})}),(0,s.jsxs)(n.td,{children:["Endian type of ",(0,s.jsx)(n.code,{children:"data"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"nomsignedfourbytesdata-endianess---nomsigned--error",children:"nomSignedFourBytes(data, endianess) -> NomSigned | Error"}),"\n",(0,s.jsx)(n.p,{children:"Nom helper to parse four bytes into signed 32 bit integer"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Uint8Array"})}),(0,s.jsx)(n.td,{children:"Bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"endianess"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Endian"})}),(0,s.jsxs)(n.td,{children:["Endian type of ",(0,s.jsx)(n.code,{children:"data"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"nomsignedeightbytesdata-endianess---nomsigned--error",children:"nomSignedEightBytes(data, endianess) -> NomSigned | Error"}),"\n",(0,s.jsx)(n.p,{children:"Nom helper to parse eight bytes into signed 64 bit integer"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Uint8Array"})}),(0,s.jsx)(n.td,{children:"Bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"endianess"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Endian"})}),(0,s.jsxs)(n.td,{children:["Endian type of ",(0,s.jsx)(n.code,{children:"data"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"nomsignedtwobytesdata-endianess---nomsigned--error",children:"nomSignedTwoBytes(data, endianess) -> NomSigned | Error"}),"\n",(0,s.jsx)(n.p,{children:"Nom helper to parse two bytes into signed 16 bit integer"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Uint8Array"})}),(0,s.jsx)(n.td,{children:"Bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"endianess"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Endian"})}),(0,s.jsxs)(n.td,{children:["Endian type of ",(0,s.jsx)(n.code,{children:"data"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"takedata-input---nom--error",children:"take(data, input) -> Nom | Error"}),"\n",(0,s.jsxs)(n.p,{children:["Nom provided string or bytes based on input length. This function exposes the\nnom ",(0,s.jsx)(n.a,{href:"https://docs.rs/nom/latest/nom/bytes/complete/fn.take.html",children:"take"})," function."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string OR Uint8Array"})}),(0,s.jsx)(n.td,{children:"String or bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"input"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"number"})}),(0,s.jsx)(n.td,{children:"How many bytes or characters nom should consume"})]})]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'function main() {\n  let test = "Hello TypeScript!";\n  let len = "Hello".length;\n  let nom_data: Nom | Error = take(test, len);\n  if (nom_data instanceof Error) {\n    console.error(`Error when parsing data ${nom_data}`);\n    return nom_data;\n  }\n\n  // We nommed ("consumed") the length of `hello`\n  console.assert(nom_data.nommed, "Hello");\n  // We stil have some string data remaining\n  console.assert(nom_data.remaining, " TypeScript!");\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Pseudo-code below for practical example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'let data = read_file("file.bin");\n// Now have bytes of a file. The file is in Little Endian format\n\n// First four bytes are the file signature\nlet sig = nomUnsignedFourBytes(data, endian.LE);\nif (sig instanceof Error) {\n  return sig;\n}\n\n// Our nom function consumed and converted the first 4 bytes to unsigned integer\nconsole.log(sig.value);\n\n// Next 2 bytes are length of UTF8 string. Our sig object contains the remaining bytes\nlet string_len = nomUnsignedTwoBytes(sig.remaining, endian.LE);\nif (string_len instanceof Error) {\n  return string_len;\n}\n\n// string_len now contains the length of the string that is next\n// Take the length of the string\nlet string_data = take(string_len.remaining, string_len.value);\nif (string_data instanceof Error) {\n  return string_data;\n}\n\n// Extract the string from the raw bytes we consumed\nlet string_value = extractUt8String(string_data.nommed);\n\nconsole.log(string_value);\n\n// Continue parsing remaining bytes with string_data.remaining\n'})}),"\n",(0,s.jsx)(n.h3,{id:"takeuntildata-input---nom--error",children:"takeUntil(data, input) -> Nom | Error"}),"\n",(0,s.jsxs)(n.p,{children:["Nom data ",(0,s.jsx)(n.strong,{children:"until"})," provided input. This function exposes the nom\n",(0,s.jsx)(n.a,{href:"https://docs.rs/nom/latest/nom/bytes/complete/fn.take_until.html",children:"take_until"}),"\nfunction. If the ",(0,s.jsx)(n.code,{children:"input"})," does not exist, we will get an error."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string OR Uint8Array"})}),(0,s.jsx)(n.td,{children:"String or bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"input"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string OR Uint8Array"})}),(0,s.jsxs)(n.td,{children:["Nom ",(0,s.jsx)(n.code,{children:"data"})," until input. Must be same type as ",(0,s.jsx)(n.code,{children:"data"})]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Psuedo-code example below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'function main() {\n  /** Here we have a very complex artifact. With lots of flags and extra data.\n   * We are only interested in some data.\n   * Luckily the data we want has signatures we can scan for\n   */\n  const data = read_file("complexArtifact.bin");\n\n  let first_sig = [1, 23, 33, 56];\n  const first_data = takeUntil(data, first_sig);\n  if (first_data instanceof Error) {\n    console.error(`Got error searching for first_data ${first_data}`);\n    return first_data;\n  }\n\n  // Now we have arrived at first_data sig. We dont care about anything we consumed to get here\n  // We have **NOT** consumed the signature yet!\n  const sig = nomUnsignedFourBytes(first_data.remaining, Endian.Le);\n  // Could technically skip this since, `takUntil` has guaranteed that we have 4 bytes remaining. Since we searched for `[1, 23, 33, 56]`\n  if (sig instanceof Error) {\n    return sig;\n  }\n\n  // Now lets get FILETIME timestamp\n  const time_data = nomUnsignedEightBytes(sig.remaining, Endian.Le);\n  if (time_data instanceof Error) {\n    return time_data;\n  }\n\n  // Convert FILETIME unsigned 64 bit value to unixepoch seconds\n  let unix_time = filetimeToUnixEpoch(time_data.value);\n  const pretty_data = new Date(unix_time * 1000);\n  const utcString = pretty_data.toUtcString();\n  console.log(`${utcString}`);\n\n  const second_sig = [83, 134, 54, 99];\n  const second_data = takeUntil(time_data.remaining, second_sig);\n  // Repeat same process above\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"takewhiledata-input---nom--error",children:"takeWhile(data, input) -> Nom | Error"}),"\n",(0,s.jsxs)(n.p,{children:["Nom data while data ",(0,s.jsx)(n.strong,{children:"IS"})," equal to input. This function exposes the nom\n",(0,s.jsx)(n.a,{href:"https://docs.rs/nom/latest/nom/bytes/complete/fn.take_while.html",children:"take_while"}),"\nfunction."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Param"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"data"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string OR Uint8Array"})}),(0,s.jsx)(n.td,{children:"String or bytes to provide to nom"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"input"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string OR number"})}),(0,s.jsxs)(n.td,{children:["Nom ",(0,s.jsx)(n.code,{children:"data"})," until input. Must be single character if ",(0,s.jsx)(n.code,{children:"data"})," is ",(0,s.jsx)(n.code,{children:"string"})," or a number <= 255 if ",(0,s.jsx)(n.code,{children:"data"})," is ",(0,s.jsx)(n.code,{children:"Uint8Array"})]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Psuedo-code example below:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'function main() {\n  // This file has an unknown amount of padding we have to deal with\n  const data = read_file("complexFile.bin");\n\n  const sig = nomUnsignedTwoBytes(data, Endian.Be);\n  if (sig instanceof Error) {\n    return sig;\n  }\n\n  // The next interesting piece of the file we want is a timestamp.\n  // But after the sig there is an unknown amount of zero padding we need to consume\n  // We **cannot** use `takeUntil` because our timestamp bytes can be anything\n\n  const pad = 0;\n  const padding_data = takeWhile(sig.remaining, pad);\n  if (padding_data instanceof Error) {\n    return padding_data;\n  }\n\n  // Our complex file uses both Big and Little Endian!\n  const time_data = nomUnsignedEightBytes(padding_data.remaining, Endian.Le);\n  const time = filetimeToUnixEpoch(time_data.value);\n  console.lot(time);\n\n  const unknown_data = nomUnsignedFourBytes(time_data.remaining, Endian.Be);\n  // Continue parsing the file\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>d});var s=t(7294);const i={},r=s.createContext(i);function d(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);